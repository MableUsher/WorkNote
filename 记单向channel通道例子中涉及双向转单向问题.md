#### 记单向channel通道例子中涉及双向转单向问题

* 背景：现有三个方法，一个只发送（写）通道
```
func counter(out chan<- int) {
    for x := 0; x < 100; x++ {
        out <- x
    }
    close(out)
}
```
* 一个只接收（读）通道
```
func printer(in <-chan int) {
    for v := range in {
        fmt.Println(v)
    }
}
```
* 一个为串联两个通道
```
func squarer(out chan<- int, in <-chan int) {
    for v := range in {
        out <- v * v
    }
    close(out)
}
```
* main方法
```
func main() {
    naturals := make(chan int)
    squares := make(chan int)
    go counter(naturals)
    go squarer(squares, naturals)
    printer(squares)
}
```
* 流程：在main方法中,首先传入一个双向通道natural，在方法中为只读通道，数据通过通道发送，同时在串联方法中，传入两个双向通道，此时natrual为只写通道，将数据写入只读通道squares，main方法中的printer写方法则接收双向通道squares，转换为只写通道，将数据打印
* 问题1：chan<-为只发送，<-chan为只接收，此处发送不是通道往外发送，而是通道作为媒介，箭头指向的是数据传输方向，即数据向通道内传输为发送数据，数据从通道流出为接收数据
* 问题2：两个双向通道在方法中都存在两次转化，在串联方法中，原本发送数据的naturals，在方法里接收数据，而在printer方法里，squares从串联方法中的发送数据变为接收数据，它们只是在方法中扮演了不同的角色，正因为它们在定义时为双向通道，所以才可以进行转化，问题是，既然它们只是扮演角色，那么在串联方法中，为什么还要将na的角色转变，他与发送方法中的na之间，是否存在联系，数据是否还是在通道中？如果不在通道中，那么通道和数据是以怎样的形式存在？
* 问题3：为何写方法不开协程而是写在主函数里？
> 在主函数中，如果三个方法作为三个协程存在，那么主协程中没有方法，会直接走完退出，没有任何输出，此时应该把输出方法写在主函数中，与协程间用通道进行关联，因为其中存在对squares通道的读操作，串联方法中sprint不发送从naturals接收的数据，主协程将一直阻塞，不会退出，

* 我的理解：问题是两个通道一个负责进一个负责出，但如果要建中转站，则要把数据进行传递，那么在串联方法中，要接收只读通道的数据，还要在只写通道中去写，此时如果存在联系，则要求当时发送的数据的通道此时能把数据接收出来，那么串联方法规定的只是通道参数的行为，而不是通道参数本身，na作为一个双向通道，在两个方法中做了不同的行为，他是在方法的要求下先转化为只读再转化为只写，它本身的性质是么有变化的，它就是一个双向通道，他可以完成读写的动作
